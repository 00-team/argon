#![allow(dead_code)]

use indoc::formatdoc;
use route::ApiRoute;
use types::ApiType;

use crate::openapi::OpenApi;
use std::collections::{HashMap, HashSet};
use std::io::Write;

mod route;
mod types;

#[derive(Debug)]
pub struct ApiSchema {
    types: HashMap<String, ApiType>,
    route: HashMap<String, ApiRoute>,
    api_version: String,
}

impl ApiSchema {
    pub fn from_openapi(oa: &OpenApi) -> Self {
        let len = oa.components.schemas.len() + oa.paths.len() * 2;
        let mut aps = Self {
            types: HashMap::with_capacity(len),
            route: HashMap::with_capacity(oa.paths.len()),
            api_version: oa.info.version.clone(),
        };

        for (k, v) in oa.components.schemas.iter() {
            let at = ApiType::parse_openapi(
                Some(k.to_string()),
                v,
                HashSet::from_iter([k.to_string()]),
                &mut aps.types,
                &oa.components.schemas,
            );
            if matches!(at.kind, types::ApiKind::Unknown) {
                panic!("unknown: {k:?} : {v:#?}");
            }
            aps.types.insert(k.to_string(), at);
        }

        for (url, pi) in oa.paths.iter() {
            macro_rules! dop {
                ($($name:ident),*) => {
                    $(if let Some(op) = &pi.$name {
                        let ar = ApiRoute::parse_openapi(
                            url,
                            stringify!($name),
                            op,
                            &mut aps.types,
                            &oa.components.schemas,
                        );
                        aps.route.insert(ar.name.to_string(), ar);
                    })*
                };
            }

            dop!(get, put, post, delete, patch);
        }

        aps
    }

    pub fn generate(&self) -> std::io::Result<()> {
        let mut ts = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open("argon-data/gen.ts")?;

        let mut dart = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open("argon-data/gog/bin/gen.dart")?;

        ts.write_all(
            formatdoc! {"
                // DO NOT EDIT THIS FILE.
                // THIS IS A GENERATED FILE AND ANY EDIT WILL BE REPLACED
                import * as ud from './user_defined';
                export const API_VERSION = '{}';
                
                
            ", self.api_version}
            .as_bytes(),
        )?;

        dart.write_all(
            formatdoc! {r#"
                // DO NOT EDIT THIS FILE.
                // THIS IS A GENERATED FILE AND ANY EDIT WILL BE REPLACED
                // import * as ud from './user_defined';

                import 'package:http/http.dart' as http;
                import 'package:freezed_annotation/freezed_annotation.dart';

                part 'gen.freezed.dart';
                part 'gen.g.dart';

                const API_VERSION = "{}";

                typedef JsonObject = Map<String, dynamic>;
                
                
            "#, self.api_version}
            .as_bytes(),
        )?;

        for (n, r) in self.types.iter() {
            // if r.user_defined {
            //     continue;
            // }

            let body = r.body_ts(false);
            let exp = format!("export type {n} = {body};\n");
            ts.write_all(exp.as_bytes())?;

            let body = r.def_dart(false);
            // let exp = format!("typedef {n} = {body};\n");
            dart.write_all(body.as_bytes())?;
            dart.write(b"\n")?;
        }

        for (_, r) in self.route.iter() {
            ts.write_all(r.def_ts().as_bytes())?;
            dart.write_all(r.def_dart().as_bytes())?;
        }

        Ok(())
    }
}
